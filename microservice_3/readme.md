# Docker

## 1. Container
 - 프로세스 분리 및 애플리케이션 패키징
 - 컨테이너 이미지는 코드, 런타임, 시스템 도구, 시스템 라이브러리, 설정 등 소프트웨어를 실행하는 데 필요한 모든 것을 포함하는 경량의 독립된 실행 가능한 패키지
 - 개발환경과 배포 준비 환경의 차이와 같은 주변 환경과 소프트웨어를 분리하며, 동일한 인프라에서 다른 소프트웨어를 실행하는 팀 간의 충돌을 줄이는데 도움이 됨
 - 컨테이너들은 상호 간에 프로세스와 파일 시스템을 분리해 동작
 - 명시적으로 지정하지 않으면 컨테이너는 서로의 파일 시스템에 접근할 수 없음
 - 명시적으로 지정하지 않으면 TCP 또는 UDP 소켓을 통해 서로 통신할 수 없음

## 2. Docker
 - 구성의 핵심 : Docker 엔진 => orchestration(컨테이너 그룹 내 컴포넌트의 관리 및 조정), 네트워크 스케쥴링 및 보안 기능을 갖춘 경량의 애플리케이션 런타임
 - 이미지 : 컨테이너의 변경할 수 없는 스냅샷
## 3. 기타 지식
- 리눅스 셸(Shell)
  - 명렁어와 프로그램을 실행할 때 사용하는 인터페이스
  - 커널(Kernel)과 사용자간의 다리 역할
  - 사용자로부터 명령을 받아 그것을 해석하고 프로그램을 실행하는 역할
  - windows의 명령 프롬프트와 비슷해보이지만 훨씬 강력한 프로그래밍 기능을 가지고 있음
    - 사용자와 커널 사이에서 명령을 해석해 전달하는 명령어 해석 기능
    - 자체 내에 프로그래밍 기능이 있어서 프로그램을 작성할 수 있음. 여려 명령을 사용해 반복적으로 수행하는 작업을 하나의 프로그램으로 제작할 수 있음 => 셸 스크립트
    - 사용자 환경 설정 기능

- alpine : linux 경량화 버전. Go 애플리케이션을 실행하는데 적합함

## 4. docker 명령
 - $docker ps
 - $docker run --rm hello-world : 
  - --rm 플래그: 종료 시 컨테이너를 제거하고 볼륨과 같은 사용이 끝난 리소스를 삭제하라는 의미
 - $docker run -it --rm alpine:latest sh
  - -it 플래그 : 대화형 터미널. 표준 입력을 컨테이너에서 실행 중인 터미널의 입력으로 매핑
  - 결과 :
    / # ls  
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var  
    - 새로 시작된 컨테이너의 루트 폴더
    - 컨테이너는 변경 불가능하므로 실행 중인 컨테이너에서 파일 시스템에 대한 모든 변경사항은 컨테이너가 중지될 때 폐기됨
    - 데이터 볼륨은 기본적으로 비영구적
    - 운영 환경 내에서 컨테이너가 실행된 상태이면 다시 시작해도 괜찮은지 확신할 수 없음
      - 컨테이너가 일반적으로 여러 호스트들의 클러스터 내에서 실행되기 때문 => 컨테이너가 어떤 호스트에서 재시작될지 확신할 수도 없고, 컨테이너가 이전에 실행 중이던 호스트가 실제로 존재한다는 보장이 없기 때문
      - 이러한 문제를 피하기 위해서는 복잡성을 완전히 피하는 것이 좋음 => 파일을 유지해야 할 때는 AWS S3나 Google Cloud Storage 등을 사용
 - $docker rm -v $(docker ps -a -q)  
   - -a: 중지된 것 포함    
   - -q: 컨테이너 id 목록만 리턴  
 - $docker run -it -v $(pwd):/host alpine:latest /bin/sh
   - -v 플래그에 대한 값의 문법은 호스트폴더:대상폴더 임
   - 경로 지정할 때는 반드시 절대 경로여야함 
 - $docker rm -v 이름
   - 이름을 지정한 컨테이너는 run 할때 --rm 플래그를 추가한다고 해도 사라지지 않기 때문에 이와 같은 방법으로 제거


## 5. docker volume
 - docker 컨테이너는 불변 상태를 유지하지만 개발 환경을 설정하는 경우와 같이 일부 파일을 디스크에 쓰거나 디스크에서 데이터를 읽어야 하는 상황도 있을 수 있음
 - Docker에는 Docker를 실행하는 호스트 기기 또는 다른 Docker 컨테이너에서 마운트할 수 있는 볼륨 개념이 있음

 1. union file system
  - 이미지를 효율적이고 컴팩트하게 유지하기 위해 사용
  - 여러 디렉토리나 파일을 그룹화해 하나의 논리적 파일 시스템으로 표현할 수 있게 함
  - 유니온 파일 시스템은 파일 시스템이 수정되는 시점에 레이어를 복사하는 "쓰기 시점 복사(Copy on Write)" 기법을 사용 => 새 이미지 만들 때 1MB 공간만 사용

 2. 볼륨 마운트
  - -v 또는 --volume 매개 변수를 사용하면 호스트에서 마운트하려는 파일 시스템에 해당하는 값과 컨테이너 내부에 볼륨을 마운트하고자 하는 경로의 쌍을 지정할 수 있음
  - -v 플래그 값의 문법은 호스트폴더:대상폴더
  - 값은 반드시 절대경로여야함

## 6. docker port
 - 컨테이너는 완전히 격리 되어 있으므로 웹 애플리케이션을 실행하는 경우 포트매핑을 해줘야함
 - 보안 관점에서 볼 때도 좋은 방법
 - docker 내부에서도 호스트 포트 매핑을 두 번 수행할 수는 없다
 - 별도의 컨테이너에서 여러 인스턴스를 시작하고 서로 다른 포트에 바인딩하는 것은 가능함
 - $docker run -it --rm -v $(pwd):/src -p 8080:8080 -w /src golang:alpine /bin/sh
    - -w : 작업 디렉토리를 설정. 컨테이너에서 실행하는 모든 명령이 이 폴더 내에서 실행된다는 것을 의미.


## 7. docker 네트워킹
 - bridge networking
    - 기본 네트워크 연결 방식
    - 이전에 연결했던 방법이 브릿지 네트워크로 연결한 것
    - docker는 네트워킹 이름 공간 및 가상 이더넷 인터페이스와 같은 리눅스의 핵심기능 사용
    - 구동 과정
      - docker 엔진 시작 -> 호스트 시스템에 docker0이라는 가상 인터페이스 생성(docker0는 연결된 다른 네트워크 인터페이스 간에 패킷을 자동으로 전달하는 가상 이더넷 브릿지) -> 컨테이너 시작 -> veth 쌍을 생성하고 그 중 하나가 컨테이너에 할당돼 eth0이 됨 -> 다른 하나는 docker0 브리지에 연결 
 - host networking
    - 본질적으로 docker 엔진이 실행되고 있는 것과 동일한 네트워크
    - 컨테이너를 호스트 네트워크에 연결하면 컨테이너에서 노출하는 모든 포트가 자동으로 호스트에 매핑되고 호스트의 IP 주소도 공유되는 방식
    - 편리하지만 동일 여러 인스턴스를 실행할 수 없게 됨
    - 비신뢰 원칙에 의해 더 이상 보호 되지 않아 보안 위험을 일으킬 수 있지만 네트워크를 과도하게 사용할 것으로 예상되는 경우와 같은 경우 적절한 경우가 있음
    - ex. API 게이트웨이
 - none
    - 네트워크에서 컨테이너를 제거하고자 할 경우 사용할 수 있음
    - 파일에 저장된 데이터만 처리하는 애플리케이션을 구현할때 사용
 - overlay networking
    - 별도의 호스트에서 실행되는 컨테이너들을 서로 연결하는 데 사용되는 고유한 docker 네트워크
    - 가용성을 높이기 위한 설정의 일부로 여러 컨테이너를 실행하는 여러 호스트를 실행하는 방식

## 8. 사용자 정의 브리지 네트워크 만들기
 - $docker network ls : 현재 네트워크 확인
    - 아무런 컨테이너도 실행하지 않았다면 일반적인 경우 3개(host, bridge, none)가 있을 것임
    - docker가 제대로 동작하려면 이 네트워크들이 제대로 동작해야 하므로 삭제하면 안됨
 - $docker network create 이름 : 네트워크 만들기


## 9. Dockerfiles
 - 이미지의 레시피
 - 기존 이미지와 설치될 소프트웨어를 정의하고 애플리케이션에 필요한 다양한 구조를 설정할 수 있는 기능을 제공
 - 생성하려는 이미지는 애플리케이션을 실행하는 데 필요한 소프트웨어만 포함하므로 공격면을 줄이면서 이미지를 만듬
 - $CGO_ENABLED=0 GOOS=linux GOARCH=386 go build -a -installsuffix cgo -ldflags '-s' -o server
    - -ldflags에 "-s" 인수를 전달하면 이 인수는 애플리케이션을 빌드할 때 -s 인수를 링커에 전달하고 모든 종속성을 정적으로 링크하도록 지시 => scratch 컨테이너를 기본이미지로 쓸 때 매우 유용함
    - 가벼운 이미지화 하면서 GLibC에 의존성을 있어서 이를 정적파일 server을 링크하여 바이너리로 build 할 수 있도록 함
 - FROM : 후속 명령을 실행할 기본 이미지 설정
    - 원격 레지스트리 저장되있거나 로컬로 저장된 이미지 사용 가능
    - go를 실행하는 데는 애플리케이션 자체만 있으면 되기 때문에 scratch를 사용해 가장 작은 이미지 생성할 수 있음
 - EXPOSE
    - docker에게 컨테이너가 런타임에 지정된 네트워크 포트에서 수신 대기 한다는 것을 알려줌
    - 특정 포트로 호스트에 접근할 수 있도록 해주는 것은 아니며, 이는 여전히 -p 맵핑을 사용해 설정해줘야 함
 - COPY
    - 첫번째 출처에서 두번째 부분에 지정된 대상으로 파일을 복사
    - COPY `<src> <dest>`
    - COPY `"<src>" "<dest>"` -> 경로에 공백이 포함될 때
    - 상대경로로 지정할 수 없음
    - `<dest>` 가 없는 COPY 명령은 WORKDIR 내에 원래 이름과 동일한 파일 또는 폴더로 복사됨
 - ENTRYPOINT
    - 컨테이너가 시작될 때 실행하고자 하는 실행 파일을 구성할 수 있게 해줌
    - docker run 뒤에 나오는 명령의 인수를 지정할 수 있음
    - ENTRYPOINT ["실행파일", "인수1","인수2"] // 기본 형식
    - ENTRYPOINT 명령 인수1 인수2 // 쉘 형식
 - CMD
    - 세 가지 형식 존재
      - CMD ["실행파일","인수1","인수2"] // exec 형식
      - CMD ["인수1","인수2"] // ENTRYPOINT에 기본 매개 변수 추가
      - CMD 명령 인수1 인수2 // 쉘 형식
    - docker 파일에는 하나의 CMD 명령만 허용

 - dockerfile 에서 명령어를 실행할 때마다 docker는 새 레이어를 만든다 => 명령을 변경하면 해당 레이어가 완전히 다시 만들어지고 잠재적으로 이후 의 모든 레이어가 새로 만들어져 빌드 속도가 크게 저하될 수 있음
  => 명령어 grouping 해야함

   - ex.   
   RUN apt-get update  
   RUN apt-get install -y wget
   RUN apt-get install -y curl
   RUN apt-get install -y nginx
   =>   
   RUN apt-get update && apt-get install -y wget curl nginx

 - dockerfile 로 이미지 만들기
   - $docker build -t testserver .
      - -t : 태그 이름 달기
 - docker build context
   - docker bbuild 명령을 실행할 때 컨텍스트 경로를 마지막 인수로 설정
   - 명령이 실행되면 실제로는 컨텍스트가 서버로 전송
   - 원본 폴더가 크면 이로 인해 문제가 발생할 수 있으므로 컨테이너를 빌드할 때는 컨테이너 내부로 패키지화해야하는 파일이나 필요한 파일만 보내는 것이 좋은 방법임
   - 이 문제를 줄일 수 있는 방법
      1. 컨텍스트가 필요한 파일만 가지고 있는지 확인 => 항상 가능한 것 아님
      2. .dockerignore 파일을 사용

   - docker ignore 파일
      - 엔진에 컨텍스트를 보내기 전에 .dockerignore 파일의 패턴과 일치하는 파일 및 디렉토리를 제외
      - .gitignore와 유사함
        - `# 주석` : 무시
        - `*/temp*` : 루트의 모든 하위 디렉토리에서 temp로 시작하는 파일 및 디렉토리 제외
        - `*/*/temp*` : 루트의 두 단계 아래 있는 하위 디렉토리에서 temp로 시작하는 파일이나 디렉토리는 제외
        - `temp?` : 루트 디렉토리에서 이름이 temp 뒤에 오는 한 문자로 이루어진 파일 및 디렉토리는 제외

 - 컨테이너에서 데몬 실행
      - 많이 사용하지만 실제로 안티 패턴임
        - 데몬 실행 프로그램들은 docker에서 애플리케이션을 정상적으로 중지시키기 위해 PID1로 시작하고 사용자 애플리케이션들은 다른 프로세스 ID로 시작되기 때문에 이렇게 Docker 컨테이너를 중지하면 사용자 애플리케이션은 종료 되지 않음
        - 이로 인해 docker stop 명령이 실행될 때 컨테이너가 멈춰버릴 수 있음
        - 충돌이 발생한 후에도 애플리케이션이 계속 실행되도록 하려면 이 책임을 docker 컨테이너를 시작하는 관리자에게 위임해야 함


## 10. docker compose
 - yaml 파일에 저장된 스택(애플리케이션 개발 언어, 프레임워크, 데이터베이스 등 기술 및 도구 일체) 정의를 통해 여러 컨테이너를 동시에 시작할 수 있음
 - docker compose에서 자주 부딪치는 문제 : compose에게 애플리케이션을 언제 실행해야하는지 알려줄 수 있는 현실적인 방법이 없음
    - depends-on 구성을 사용하더라도 compose에게 종속성 여부와 서비스의 시작 순서를 조절해야 한다는 사실을 알려줄 수 밖에 없음
 - compose가 수행할 작업은 컨테이너가 시작됐는지 확인 하는것
    - 컨테이너가 시작됐다는 것이 요청을 처리할 준비가 됬다는 것은 아님
- docker-compose up
- docker-compose rm -v
- docker-compose -f ./docker-compose.yml up
- docker-compose -p testproject up

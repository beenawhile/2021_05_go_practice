# RESTful API 디자인

## 1. RESTful API
  - REpresentational State Transfer (표현적 상태 전송)의 약자
  - 다음과 같은 REST 원칙을 준수하는 API 사용시 RESTful API 라 칭함
    - 컴포넌트 간 상호작용의 확장성, 범용적인 인터페이스, 컴포넌트의 독립적인 배포를 강조
    - 응답 지연시간 감소, 보안 강화, 레거시 시스템의 캡슐화를 위한 중간 컴포넌트

## 2. URI
 - API에 접근하는 방법
 - HTTP 프로토콜의 주요 구성 요소 중 하나
 - Uniform Resource Identifiers

## 3. URL
 - 네트워크 위치로 리소스를 식별하는 URI
 - URI와의 차이점? 없음

## 4. URI 형식
 - URI = scheme "://" authority "/" path ["?" query] ["#" fragment]
    - path : 서버에서 실행 중인 엔드 포인트의 위치를 찾기 위해 사용
    - query : 페이지 번호와 같은 매개 변수를 전달하거나 변환된 데이터를 제어하기 위해 순서 지정을 사용
 - URI 형식 지정에 대한 일반적 규칙
    - / 는 리소스 사이의 계층적 관계를 나타내는 데 사용
    - URI의 마지막에 / 가 포함돼서는 안된다
    - 가독성을 높이기 위해 하이픈(-)을 사용해야 함
    - 밑줄 문자(_, underscore)는 URI에 사용하면 안 됨
    - URI 경로 부분은 대소문자를 구분하므로 소문자를 사용하는 것이 좋음

## 5. REST 서비스를 위한 URI 경로 설계
 - 경로는 1) 문서, 2) 컬렉션, 3) 저장소, 4) 컨트롤러 로 구분됨

 1) 컬렉션
  - 개별 문서에 접근하기 위한 매개 변수로 구분되는 여러 리소스가 들어 있는 하나의 디렉토리  
  ex)  
      GET /cats     -> 모든 고양이가 컬렉션에 들어 있음  
      GET /cats/1   -> 1번 고양이를 위한 하나의 문서  

 2) 문서
  - 데이터베이스의 행과 비슷한 하나의 객체를 가리키는 리소스
  - 하나의 문서는 하위 문서 또는 컬렉션과 같은 하위 리소스를 가질 수 있음  
  ex)  
      GET /cats/1             -> 1번 고양이를 위한 하나의 문서
      GET /cats/1/kittens     -> 1번 고양이의 모든 새끼 고양이들
      GET /cats/1/kittens/1   -> 1번 고양이의 1번 새끼 고양이

 3) 컨트롤러
  - 컨트롤러 리소스는 프로시저와 비슷하지만 일반적으로 리소스를 표준 CRUD 기능에 매핑할 수 없는 경우
  - 컨트롤러의 이름은 하위 리소스가 없는 URI 경로의 마지막 segment
  - 컨트롤러에 매개 변수가 필요한 경우, 일반적으로 쿼리 문자열에 이 매개 변수가 포함됨  
  ex)    
      POST /cats/1/feed             -> 1번 고양이에게 먹이 주기    
      POST /cats/1/feed?food=fish   -> 1번 고양이에게 물고기를 먹이로 주기  

 4) 저장소
  - 클라이언트가 관리하는 리소스 저장소
  - 클라이언트가 리소스를 추가, 검색 및 삭제할 수 있게 함
  - 컬렉션과 달리 저장소는 새로운 URI를 생성하지 않으며, 클라이언트가 지정한 URI를 사용  
  ex)  
      PUT /cats/2             -> 새 고양이 추가  

 5) CRUD 함수 이름
  - URI의 일부로 CRUD 함수 이름을 사용하지 않고 대신 **HTTP 동사**를 사용    
  ex)  
      DELETE /cats/1234             -> 고양이 제거

## 6. HTTP 동사
 - GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS  
 - 각 메서드는 REST API의 맥락에서 잘 정의된 의미를 가지고 있으며, 제대로 구현하면 사용자가 개발자의 의도를 이해하는데 도움이 됨    


  1) GET  
   - 리소스를 검색하는 데 사용  
   - 레코드 업데이트와 같은 변경 작업에 사용해서는 안됨  
   - 일반적으로 GET 요청은 본문을 함께 전달하지 않지만, 그렇게 한다고 해서 유효하지 않은 HTTP 요청인 것은 아님
  2) POST
   - 컬렉션에 **새로운 리소스를 만들**거나 **컨트롤러를 실행**하는 데 사용
   - 일반적으로 비멱등(non-idempotent, 반복 수행 시 매번 변경 발생) 동작
   - 컬렉션에 하나의 요소를 만드는 POST 요청을 여러 번 보내면 첫 번째 호출 시와 동일한 요소가 여러 개 생성됨
  3) PUT  
   - 변경 가능한 리소스를 업데이트하는 데 사용되며 항상 리소스 식별정보를 포함해야 함
   - 여러 번 요청해도 한 번 요청한 것과 동일한 리소스 상태를 유지하는 멱등성을 가짐
  4) PATCH  
   - 부분 업데이트를 수행하는 데 사용
   - 거의 사용되지 않음
  5) DELETE  
   - 리소스를 제거하려는 경우에 사용
   - 본문이 아닌 경로의 일부로 제거하려는 리소스의 ID를 전달
   - 일관성 있게 문서를 업데이트, 삭제 및 검색할 수 있음
  6) HEAD  
   - 클라이언트는 본문 없이 리소스에 대한 헤더만 검색하려는 경우 사용
   - 클라이언트가 서버에 리소스가 있는지 확인하거나 메타 데이터를 읽으려는 때만 GET 대신 사용
  7) OPTIONS  
   - 클라이언트가 서버의 리소스에 대해 수행 가능한 동작을 알아보려고 할 때 사용
   - 일반적으로 서버는 이 리소스에 대해 사용할 수 있는 HTTP 동사를 포함하는 Allow 헤더를 리턴

## 7. URI query design
 - 쿼리는 다음과 같은 작업을 수행하는데 사용해야 함
    - 페이지 처리  
    - 필터링  
    - 정렬  
 - POST 중 컨트롤러의 동작을 선택할 때 쿼리 문자열을 사용할 수 있음
  - 본문을 사용하지 않고 쿼리에 파라미터를 담을 때 문제점  
    (1) URI 최대 길이가 2083 문자로 제한 됨  
    (2) POST 요청이 일반적으로 항상 요청의 본문을 포함함  

## 8. 응답코드
 - 전부 다루지 않고 마이크로서비스가 리턴했으면 하는 상태코드만 다룸
 - 본문을 깊이 있게 살펴보지 않더라도 요청의 상태를 즉각적으로 알 수 있게 해주는 것이 좋은 관행이라는 인식이 있음

1. 2xx Success
- 클라이언트의 요청이 성공적으로 수신되고 이해됐음을 나타냄

  (1) 200 OK  
    - 요청이 성공됬음을 나타냄. 이 코드와 함께 전송되는 응답은 일반적으로 다음과 같음  
      * GET : 요청된 리소스에 해당하는 엔티티  
      * HEAD : 메시지 본문 없이 요청된 리소스에 해당하는 헤더 필드  
      * POST : 처리 결과를 설명하거나 포함하고 있는 엔티티  

   (2) 201 Created
    - 요청이 성공하고 새 엔티티가 생성된 경우  
    - 일반적으로는 API는 응답과 함께 새로 생성된 엔티티의 위치가 있는 Location 헤더를 리턴

   (3) 204 No Content  
    - 요청이 성공적으로 처리 됐으나 응답에 메시지의 본문이 없음  
    - DELETE 요청을 하면 받을 수 있는 응답  

2. 3xx Redirection
- 클라이언트가 요청을 완료하기 위해 추가 조치를 취해야함을 나타내는 상태코드 클래스
- 대부분 CDN 및 기타 콘텐츠 리디렉션 기법에서 사용되지만, 304 코드는 클라이언트에게 의미론적 피드백을 제공하기 위해 API를 설계할 때 매우 유용할 수 있음

  (1) 301 Moved Permanently 영구적 이동
   - 리소스가 영구적으로 다른 위치로 이동됐음을 클라리언트에게 알려줌
   - 전통적으로 웹 서버의 페이지나 리소스를 리다이렉트하는 데 사용
   - API 빌드할 때도 유용하게 쓸 수 있음 (컬렉션 이름을 변경한 경우 301 리디렉션을 사용해 클라이언트를 올바른 위치로 보낼 수 있음)

  (2) 304 Not Modified
   - CDN 또는 캐싱 서버에서 사용됨, API에 대한 마지막 호출 이후 응답이 변경되지 않았음을 나타냄
   - 대역폭을 절약하기 위해 설계됐고, 본문을 반환하지 않지만 Content-Location 및 Expires 헤더를 리턴  

3. 4xx Client Error
 - 서버가 아닌 클라이언트로 인해 발생한 에러의 경우
 - 항상 에러에 대한 자세한 내용을 제공하는 엔티티를 리턴

  (1) 400 Bad Request
   - 잘못된 형식의 요청 또는 도메인 유효성 검사 실패(데이터 누락 및 잘못된 상태 초래할 수 있는 작업)로 인해 클라이언트가 요청을 이해할 수 없음을 의미

  (2) 401 Unauthorized
   - 사용자 인증을 요구하고, 리소스를 요청하는데 사용할 수 있는 챌린지를 포함하는 www-authenticate 헤더를 포함하고 있을 때 나타냄  

  (3) 403 Forbidden
   - 서버가 요청을 이해했지만 요청에 대한 실행을 거부하는 것
   - 인증되지 않은 사용자가 리소스에 대해 잘못된 수준으로 접근을 요청했기 때문
   - 서버가 접근 수준의 제한으로 인해 특정 리소스에 접근할 수 없다는 사실을 공개하고 싶지 않다면, 404 상태를 리턴할 수 있음
  
  (4) 405 Method Not Allowed
   - 요청에 지정된 메서드가 URI로 표시된 리소스에 허용되지 않음을 의미
   - 클라이언트가 문서 조회만 제공하는 컬렉션에 POST, PUT, PATCH를 전송해 컬렉션을 변경하려는 경우 일 수 있음
   
  (3) 403 Forbidden
   - 서버가 요청을 이해했지만 요청에 대한 실행을 거부하는 것
   - 인증되지 않은 사용자가 리소스에 대해 잘못된 수준으로 접근을 요청했기 때문
   - 서버가 접근 수준의 제한으로 인해 특정 리소스에 접근할 수 없다는 사실을 공개하고 싶지 않다면, 404 상태를 리턴할 수 있음
4. 5xx Server Error

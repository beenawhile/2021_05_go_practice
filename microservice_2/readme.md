# RESTful API 디자인

## 1. RESTful API
  - REpresentational State Transfer (표현적 상태 전송)의 약자
  - 다음과 같은 REST 원칙을 준수하는 API 사용시 RESTful API 라 칭함
    - 컴포넌트 간 상호작용의 확장성, 범용적인 인터페이스, 컴포넌트의 독립적인 배포를 강조
    - 응답 지연시간 감소, 보안 강화, 레거시 시스템의 캡슐화를 위한 중간 컴포넌트

## 2. URI
 - API에 접근하는 방법
 - HTTP 프로토콜의 주요 구성 요소 중 하나
 - Uniform Resource Identifiers

## 3. URL
 - 네트워크 위치로 리소스를 식별하는 URI
 - URI와의 차이점? 없음

## 4. URI 형식
 - URI = scheme "://" authority "/" path ["?" query] ["#" fragment]
    - path : 서버에서 실행 중인 엔드 포인트의 위치를 찾기 위해 사용
    - query : 페이지 번호와 같은 매개 변수를 전달하거나 변환된 데이터를 제어하기 위해 순서 지정을 사용
 - URI 형식 지정에 대한 일반적 규칙
    - / 는 리소스 사이의 계층적 관계를 나타내는 데 사용
    - URI의 마지막에 / 가 포함돼서는 안된다
    - 가독성을 높이기 위해 하이픈(-)을 사용해야 함
    - 밑줄 문자(_, underscore)는 URI에 사용하면 안 됨
    - URI 경로 부분은 대소문자를 구분하므로 소문자를 사용하는 것이 좋음

## 5. REST 서비스를 위한 URI 경로 설계
 - 경로는 1) 문서, 2) 컬렉션, 3) 저장소, 4) 컨트롤러 로 구분됨

 1) 컬렉션
  - 개별 문서에 접근하기 위한 매개 변수로 구분되는 여러 리소스가 들어 있는 하나의 디렉토리  
  ex)  
      GET /cats     -> 모든 고양이가 컬렉션에 들어 있음  
      GET /cats/1   -> 1번 고양이를 위한 하나의 문서  

 2) 문서
  - 데이터베이스의 행과 비슷한 하나의 객체를 가리키는 리소스
  - 하나의 문서는 하위 문서 또는 컬렉션과 같은 하위 리소스를 가질 수 있음  
  ex)  
      GET /cats/1             -> 1번 고양이를 위한 하나의 문서
      GET /cats/1/kittens     -> 1번 고양이의 모든 새끼 고양이들
      GET /cats/1/kittens/1   -> 1번 고양이의 1번 새끼 고양이

 3) 컨트롤러
  - 컨트롤러 리소스는 프로시저와 비슷하지만 일반적으로 리소스를 표준 CRUD 기능에 매핑할 수 없는 경우
  - 컨트롤러의 이름은 하위 리소스가 없는 URI 경로의 마지막 segment
  - 컨트롤러에 매개 변수가 필요한 경우, 일반적으로 쿼리 문자열에 이 매개 변수가 포함됨  
  ex)    
      POST /cats/1/feed             -> 1번 고양이에게 먹이 주기    
      POST /cats/1/feed?food=fish   -> 1번 고양이에게 물고기를 먹이로 주기  

 4) 저장소
  - 클라이언트가 관리하는 리소스 저장소
  - 클라이언트가 리소스를 추가, 검색 및 삭제할 수 있게 함
  - 컬렉션과 달리 저장소는 새로운 URI를 생성하지 않으며, 클라이언트가 지정한 URI를 사용  
  ex)  
      PUT /cats/2             -> 새 고양이 추가  

 5) CRUD 함수 이름
  - URI의 일부로 CRUD 함수 이름을 사용하지 않고 대신 **HTTP 동사**를 사용    
  ex)  
      DELETE /cats/1234             -> 고양이 제거

## 6. HTTP 동사
 - GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS  
 - 각 메서드는 REST API의 맥락에서 잘 정의된 의미를 가지고 있으며, 제대로 구현하면 사용자가 개발자의 의도를 이해하는데 도움이 됨    


  1) GET  
   - 리소스를 검색하는 데 사용  
   - 레코드 업데이트와 같은 변경 작업에 사용해서는 안됨  
   - 일반적으로 GET 요청은 본문을 함께 전달하지 않지만, 그렇게 한다고 해서 유효하지 않은 HTTP 요청인 것은 아님
  2) POST
   - 컬렉션에 **새로운 리소스를 만들**거나 **컨트롤러를 실행**하는 데 사용
   - 일반적으로 비멱등(non-idempotent, 반복 수행 시 매번 변경 발생) 동작
   - 컬렉션에 하나의 요소를 만드는 POST 요청을 여러 번 보내면 첫 번째 호출 시와 동일한 요소가 여러 개 생성됨
  3) PUT  
   - 변경 가능한 리소스를 업데이트하는 데 사용되며 항상 리소스 식별정보를 포함해야 함
   - 여러 번 요청해도 한 번 요청한 것과 동일한 리소스 상태를 유지하는 멱등성을 가짐
  4) PATCH  
   - 부분 업데이트를 수행하는 데 사용
   - 거의 사용되지 않음
  5) DELETE  
   - 리소스를 제거하려는 경우에 사용
   - 본문이 아닌 경로의 일부로 제거하려는 리소스의 ID를 전달
   - 일관성 있게 문서를 업데이트, 삭제 및 검색할 수 있음
  6) HEAD  
   - 클라이언트는 본문 없이 리소스에 대한 헤더만 검색하려는 경우 사용
   - 클라이언트가 서버에 리소스가 있는지 확인하거나 메타 데이터를 읽으려는 때만 GET 대신 사용
  7) OPTIONS  
   - 클라이언트가 서버의 리소스에 대해 수행 가능한 동작을 알아보려고 할 때 사용
   - 일반적으로 서버는 이 리소스에 대해 사용할 수 있는 HTTP 동사를 포함하는 Allow 헤더를 리턴

## 7. URI query design
 - 쿼리는 다음과 같은 작업을 수행하는데 사용해야 함
    - 페이지 처리  
    - 필터링  
    - 정렬  
 - POST 중 컨트롤러의 동작을 선택할 때 쿼리 문자열을 사용할 수 있음
  - 본문을 사용하지 않고 쿼리에 파라미터를 담을 때 문제점  
    (1) URI 최대 길이가 2083 문자로 제한 됨  
    (2) POST 요청이 일반적으로 항상 요청의 본문을 포함함  

## 8. 응답코드
 - 전부 다루지 않고 마이크로서비스가 리턴했으면 하는 상태코드만 다룸
 - 본문을 깊이 있게 살펴보지 않더라도 요청의 상태를 즉각적으로 알 수 있게 해주는 것이 좋은 관행이라는 인식이 있음

1. 2xx Success
- 클라이언트의 요청이 성공적으로 수신되고 이해됐음을 나타냄

  (1) 200 OK  
    - 요청이 성공됬음을 나타냄. 이 코드와 함께 전송되는 응답은 일반적으로 다음과 같음  
      * GET : 요청된 리소스에 해당하는 엔티티  
      * HEAD : 메시지 본문 없이 요청된 리소스에 해당하는 헤더 필드  
      * POST : 처리 결과를 설명하거나 포함하고 있는 엔티티  

   (2) 201 Created
    - 요청이 성공하고 새 엔티티가 생성된 경우  
    - 일반적으로는 API는 응답과 함께 새로 생성된 엔티티의 위치가 있는 Location 헤더를 리턴

   (3) 204 No Content  
    - 요청이 성공적으로 처리 됐으나 응답에 메시지의 본문이 없음  
    - DELETE 요청을 하면 받을 수 있는 응답  

2. 3xx Redirection
- 클라이언트가 요청을 완료하기 위해 추가 조치를 취해야함을 나타내는 상태코드 클래스
- 대부분 CDN 및 기타 콘텐츠 리디렉션 기법에서 사용되지만, 304 코드는 클라이언트에게 의미론적 피드백을 제공하기 위해 API를 설계할 때 매우 유용할 수 있음

  (1) 301 Moved Permanently 영구적 이동
   - 리소스가 영구적으로 다른 위치로 이동됐음을 클라리언트에게 알려줌
   - 전통적으로 웹 서버의 페이지나 리소스를 리다이렉트하는 데 사용
   - API 빌드할 때도 유용하게 쓸 수 있음 (컬렉션 이름을 변경한 경우 301 리디렉션을 사용해 클라이언트를 올바른 위치로 보낼 수 있음)

  (2) 304 Not Modified
   - CDN 또는 캐싱 서버에서 사용됨, API에 대한 마지막 호출 이후 응답이 변경되지 않았음을 나타냄
   - 대역폭을 절약하기 위해 설계됐고, 본문을 반환하지 않지만 Content-Location 및 Expires 헤더를 리턴  

3. 4xx Client Error
- 서버가 아닌 클라이언트로 인해 발생한 에러의 경우
- 항상 에러에 대한 자세한 내용을 제공하는 엔티티를 리턴

  (1) 400 Bad Request
   - 잘못된 형식의 요청 또는 도메인 유효성 검사 실패(데이터 누락 및 잘못된 상태 초래할 수 있는 작업)로 인해 클라이언트가 요청을 이해할 수 없음을 의미 

  (2) 401 Unauthorized
   - 사용자 인증을 요구하고, 리소스를 요청하는데 사용할 수 있는 챌린지를 포함하는 www-authenticate 헤더를 포함하고 있을 때 나타냄    

  (3) 403 Forbidden  
   - 서버가 요청을 이해했지만 요청에 대한 실행을 거부하는 것
   - 인증되지 않은 사용자가 리소스에 대해 잘못된 수준으로 접근을 요청했기 때문
   - 서버가 접근 수준의 제한으로 인해 특정 리소스에 접근할 수 없다는 사실을 공개하고 싶지 않다면, 404 상태를 리턴할 수 있음  
  
  (4) 405 Method Not Allowed
   - 요청에 지정된 메서드가 URI로 표시된 리소스에 허용되지 않음을 의미
   - 클라이언트가 문서 조회만 제공하는 컬렉션에 POST, PUT, PATCH를 전송해 컬렉션을 변경하려는 경우 일 수 있음  
  
  (5) 403 Forbidden
   - 서버가 요청을 이해했지만 요청에 대한 실행을 거부하는 것
   - 인증되지 않은 사용자가 리소스에 대해 잘못된 수준으로 접근을 요청했기 때문
   - 서버가 접근 수준의 제한으로 인해 특정 리소스에 접근할 수 없다는 사실을 공개하고 싶지 않다면, 404 상태를 리턴할 수 있음
  

4. 5xx Server Error
- 무언가 생긴 상황이며 서버가 이 내용을 알고 있음
- 너무 많은 메세지를 보내면 보안상으로 위험할 수 있기 때문에 매우 일반적인 내용만 리턴하는 추세    
  
 (1) 500 internal server error 내부 서버 에러   
  - 뭔가가 계획대로 진행되지 않았음을 나타내는 메세지  

 (2) 503 Service Unavailable 서비스 이용 불가
  - 일시적인 과부하 또는 유지 관리로 인해 현재 서버를 사용할 수 없는 상태
  - 마이크로서비스가 내부 상태를 모니터링하면서 오작동이나 과부하 발생 시, 더 이상 요청을 받아들이지 않도록 하는 패턴


## 8. HTTP 헤더
 - http 요청 및 응답 프로세스에서 매우 중요한 요소
 

1. 표준 요청 헤더
 - 콘텐츠 인코딩처럼 본문에 포함되지 않으면서 응답의 다른 데이터를 보완하는 데 사용
 - 클라이언트가 서버의 응답 처리에 도움이 되는 정보를 제공하기 위해 요청 헤더를 사용
 - 표준헤더를 사용하면 사용자에게 일관성을 부여하고 다양한 공급 업체의 여러 엔드 포인트에서 공통된 표준을 제공할 수 있으므로 가능하면 항상 사용해야함
2. Authorization - 문자열
 - 가장 일반적으로 사용되는 요청 헤더 중 하나
 - 공개된 읽기 전용 API라도 사용자에게 권한 요청을 요구하는 것이 좋음
3. Date
 - RFC 3339 형식에 있는 요청의 타임스탬프
4. Accept - 콘텐츠 타입
 - 응답으로 요청된 컨텐츠 타입
 - application/xml, text/xml, text/javascript, application/json 등
5. Accept-Encoding - gzip, release
 - REST API 엔드포인트가 가능한 경우 항상 지원해야함
6. 표준 응답 헤더
 - 모든 서비스는 다음 헤더를 리턴해야함
    - Date : RFC 3339 형식에 포함돼 있으며 요청이 처리된 날짜
    - Content-Type : 응답의 콘텐츠 타입
    - Content-Encoding : gzip 도는 deflate
    - X-Request-ID/X-Correlation-ID : 클라이언트에서 이 헤더를 구현하도록 직접 요청하지 않음. 다운 스트림 서비스(서버에서 클라이언트로 보내는 요청)를 호출 할 때 요청에 추가할 수 있음. 트랜잭션 id로 모든 요청을 그룹화하면 매우 유용할 수 있음.
7. 에러 리턴
 - API 사용자는 에러가 발생했을 때 여러 엔드 포인트에서 발생한 에러를 처리하는 하나의 코드를 작성할 수 있어야 함 => 표준 에러 엔티티가 에러가 발생할 때 마다 반복 없는 코드를 작성할 수 있게 클라이언트를 도움


 ## 9. 자바스크립트에서 API 접근
  - 사용자 데이터 검색을 허용하는 API, 이 API 인터페이스를 제공하는 웹사이트가 있을 때, 브라우저가 동일 출처 정책을 구현하지 않은 상태에서 사용자가 자신의 세션에서 로그 아웃하지 않는다고 가정하면, 악성 페이지가 사용자에게 알리지 않고 API에 요청을 보내고 수정할 수 있음
  - 이러한보안 문제를 해결하면서 마이크로서비스가 이러한 접근을 허용하도록 구현할 수 있는 방법
  => JSONP (패딩된 JSON), CORS(Cross-Origin Resource Sharing)

1. JSONP
 - 거의 해킹에 가깝다?
 - CORS 표준을 구현하지 않은 대부분의 브라우저에서 구현됨
 - GET 요청만 가능
 - 서드 파티 서버에 대한 요청에서 XMLHTTPRequest는 차단되는 반면 HTML 스크립트 요소에 대한 제한은 없다는 문제점을 이용해 작동
 - 브라우저의 DOM에 <script src=\"...\"> 요소를 삽입하는데, 이때 src의 대상은 API URL. 이 컴포넌트는 JSON 데이터를 매개변수하는 함수의 호출을 리턴, 페이지가 로드되면 함수가 실행되면서 데이터를 콜백 함수로 전달
- 주의할 점 : Content-Type 헤더에 application/json이 아니라 적절한 헤더를 설정해줘야함

2. CORS
 - 브라우저에서 서로 다른 도메인간의 요청을 표준화하는 W3C의 제안
 - 내장된 HTTP 클라이언트가 실체 요청 전에 URI에 OPTIONS 요청을 하는 브라우저에서 작동함
 - 한 서버가 스크립트가 로드되는 다른 도메인의 출처를 포함한 다음과 같은 헤더를 리턴하면, 브라우저는 서버를 신뢰하고 두 사이트 간의 요청을 허용
      Access-Control-Allow-Origin: origin.com


 ## 10. RPC API
 1. RPC
  - 같은 기기 또는 원격 장비에 있는 함수나 메서드를 실행하는 방법
  - 인터넷이 나오기 전 시대에는 첨단 기술 이었음
  - 
  - REST가 HTTP를 전송 계층으로 사용해야하는데 반해 RPC는 이런 제약이 없음 => 성공의 지표로 HTTP 상태 코드를 사용할 수 없을 수 있음
  - HTTP를 통해 RPC 호출을 보낼 수 있고 원하는 경우 좀 더 가벼운 TCP나 UDP 소켓도 사용할 수 있음
  - HTTP를 사용하지 않기 때문에 대기시간이 짧아지고, JSON이나 XML이 아닌 바이너리 메시지 형식을 구현해 메시지 크기가 작기 때문에 속도가 빠르고 성능이 좋음
  - 장점 : 사용자를 위한 클라이언트를 신속하게 생성할 수 있음
  - 단점 : 클라이언트와 서버간에 긴밀한 결합이 발생할 수 있음 => API 버전 관리 절의 표준 가이드라인을 따라야 문제가 덜 발생
  - 두 프로세스 사이에서 객체를 공유하려고 시도하는 대신, 불변 객체(생성 이후 그 값을 변경할 수 없는 객체)을 리턴하는 기능적인 접근법을 취함

2. RPC 메시지 프레임워크
 - Gob
  - 인코더와 디코더 사이에서 교환된 바이너리 값
  - go 프로세스 사이의 통신을 용이하게 하기 위해 특별히 고안됐음
  - Protocol Buffer 같은 것보다 사용하기 쉬우면서 효율적일 수 있는 것을 만들려는 아이디어를 바탕으로 설계됨
  - 다른 언어 사이의 통신에서는 추가적인 비용이 발생
  